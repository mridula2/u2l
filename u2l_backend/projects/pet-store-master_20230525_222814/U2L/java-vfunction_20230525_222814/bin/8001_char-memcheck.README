# $Header: /data/cvsrepo/assess-tools/bin/8001_char-memcheck.README,v 1.1 2014/02/24 07:52:34 sodo Exp $
# $Name: rev_1_10 $
#
ツール名　: 
　8001_char-memcheck

概要　　　: 
　STKおよびcppcheckの出力結果およびソースコードから
　memset,memcpy関数で問題が発生する可能性が高い箇所を抽出する。
　また代入初期化の検出数をカウントする。

実行方法 : 
　# cd $srcdir
　# 8001_char-memcheck .
　
　※注意：入力ファイル「STK実行結果ログファイル」にはソースコードのファイルパス情報が含まれており
　　　　　本ツールはその情報をもとにソースコードを読み込みますが、
　　　　　パスはソースコード格納ディレクトリからの相対パスで記載されています。
　　　　　このため、ソースコード格納ディレクトリへcdで移動してから本ツールを実行してください。

　※注意：入力ファイル「cppcheck実行結果ログファイル」が見つかった場合、このファイルの内容を読み込み
　　　　　出力ファイルにcppcheckの警告内容を出力します。
　　　　　もし入力ファイル「cppcheck実行結果ログファイル」が見つからない場合は、
　　　　　本スクリプト内でコマンド「cppcheck <argv[0]>」を実行して「cppcheck実行結果ログファイル」を生成します。
　　　　　ただし、cppcheckは.pcファイルを検査対象に含めない仕様であるため、
　　　　　.pcファイルが含まれる場合、事前に手動でcppcheckコマンドを実行するようにしてください。

オプション：
　<directory> : コメント除去されたソースコードがあるディレクトリパス
　（そのディレクトリへcdして.を引数にしてください）

標準出力　：
　なし

戻り値：
　0：正常終了
　1：引数の数が不正
　　 入力となるソースコードディレクトリが存在しない
　　 入力となるSTK実行結果ログファイルが存在しない
　　 入力となるSTK実行結果ログファイルが読み込めない
　　 出力ファイルのオープンに失敗


エラー出力：
　引数不正："Usage: $0 dir"
　入力ソースコードがない："Not found <dir>"
　入力となるSTKログが存在しない："Not found <STKlogfile>"
　入力となるSTKログが読み込めない："Can't open <STKlogfile>"
　出力ファイルのオープンに失敗："Cant open <outputfile>"
　
入力ファイル：
　$PJHOME/log/$APNAME/stk/allfunc_detail.txt：STK実行結果ログファイル
　$PJHOME/log/$APNAME/charinv/cppcheck.out  ：cppcheck実行結果ログファイル
　
出力ファイル：
　$PJHOME/log/$APNAME/charinv/char-ext.out：目視が必要なソースコード、行番号、およびメッセージの種別が記載されたファイル
　　出力フォーマット：
　　<ファイル名>:<行番号>:<内容>:<メッセージの種別>

　cppcheck実行結果ログファイルは、そのまま出力ファイルに書き出される。（すべて問題を起こす可能性があると考えている）

　STK実行結果ログファイルは、内容によって以下のメッセージ種別を出力する（詳しい判別仕様は後述）

　　memset-OK      :memsetの第三引数が「sizeof(xxx)」となっており、かつ、sizeofの中身が第一引数と同じもの
　　memset-sizeof  :memsetの第三引数が「sizeof(xxx)」となっているが、sizeofの中身が第一引数と異なるもの
　　memset-other   :memsetの第三引数が「sizeof(xxx)」となっていないもの
　　memcpy-sizeofEQ:memcpyの第三引数が「sizeof(xxx)」となっており、かつ、sizeofの中身が第二引数と同じもの
　　memcpy-sizeofNE:memcpyの第三引数が「sizeof(xxx)」となっているが、sizeofの中身が第二引数と異なるもの
　　memcpy-struct  :memcpyの第三引数が「sizeof(xxx)」となっており、かつ、sizeofの中身が第二引数と異なり、
　　　　　　　　　　かつ第一引数が「aaa.bbb」「aaa->bbb」の形式になっているもの
　　struct         :memsetまたはmemcpyの第一引数が「aaa.bbb」「aaa->bbb」の形式になっているもの
　　other          :memset,memcpy関数で上記の条件を満たさないもの、または、memset,memcpy関数以外のもの

　STK実行結果ログファイルを再度読み込み、char配列要素の初期化個所の判定結果を出力する（詳しい判別仕様は後述）

　　assign         :char配列要素の初期化個所 (例：char tmp[10] = {'aaa', 'bbb', ccc'};)で、かつ、
　　　　　　　　　　同じ行にNULL(0x00,0,\0,"")を含まないもの

仕様：
　本スクリプトは、ソースコードディレクトリ以下から1行単位でファイル読み込みを行い、
　各行に含まれるmemset,memcpy関数およびchar配列要素の初期化個所を検出し、以下のようなパターンの行を抽出する。

　パターン判定は下記の記載順で行われる。
　memset-01のパターンを検出した場合でも次のパターン判定を継続する。（memset-01と他のパターンを両方検出するため）
　それ以外のパターンを検出した場合はその行のパターン判定を停止し、次の行の読み込みを行う。

　　memset-OKとして抽出されるパターン：
		memset( aaa, xxx, sizeof( aaa ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ
		memset( &aaa, xxx, sizeof( aaa ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第一引数に付く&は除外して比較する）
		memset( (char *)aaa, xxx, sizeof( aaa ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第一引数に付く(char *)は除外して比較する）
		memset( (char *)&aaa, xxx, sizeof( aaa ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第一引数に付く(char *)&は除外して比較する）

　　memset-sizeofとして抽出されるパターン：
		memset( aaa, XXXX, sizeof( bbb ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる
		memset( &aaa, XXXX, sizeof( bbb ) );		# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第一引数に付く&は除外して比較する)
		memset( (char *)aaa, XXXX, sizeof( bbb ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第一引数に付く(char *)は除外して比較する)
		memset( (char *)&aaa, XXXX, sizeof( bbb ) );# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第一引数に付く(char *)&は除外して比較する)

　　memset-otherとして抽出されるパターン：
		memset( aaa, XXXX, DATE_LEN );				# 第三引数がsizeofを使っていない
		memset( aaa, XXXX, bbb );					# 第三引数がsizeofを使っていない
		memset( aaa, XXXX, sizeof( aaa )*10 );		# 第三引数がsizeofを使っているが、その結果に演算処理を行っている

　　memcpy-sizeofEQとして抽出されるパターン：
		memcpy( aaa, bbb, sizeof( bbb ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第二引数と同じ
		memcpy( aaa, &bbb, sizeof( bbb ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第二引数に付く&は除外して比較する）
		memcpy( aaa, (char *)bbb, sizeof( bbb ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第二引数に付く(char *)は除外して比較する）
		memcpy( aaa, (char *)&bbb, sizeof( bbb ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と同じ(第二引数に付く(char *)&は除外して比較する）

　　memcpy-sizeofNGとして抽出されるパターン：
		memcpy( aaa, bbb, sizeof( ccc ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第二引数と異なる
		memcpy( aaa, &bbb, sizeof( ccc ) );			# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第二引数に付く&は除外して比較する）
		memcpy( aaa, (char *)bbb, sizeof( ccc ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第二引数に付く(char *)は除外して比較する）
		memcpy( aaa, (char *)&bbb, sizeof( ccc ) );	# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第一引数と異なる(第二引数に付く(char *)&は除外して比較する）

　　memcpy-structとして抽出されるパターン：
		memcpy( aaa.ddd, bbb, sizeof( ccc ) );		# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第二引数と異なり、かつ、第一引数が「aaa.ddd」となっている
		memcpy( aaa->ddd, bbb, sizeof( ccc ) );		# 第三引数がsizeofを使い、かつ、sizeofの中身の変数名が第二引数と異なり、かつ、第一引数が「aaa->ddd」となっている

　　structとして抽出されるパターン：
		memset( aaa.ddd, bbb, ccc );				# memset関数で第一引数が「aaa.ddd」となっている（他の条件は見ない）
		memset( aaa->ddd, bbb, ccc );				# memset関数で第一引数が「aaa->ddd」となっている（他の条件は見ない）
		memcpy( aaa.ddd, bbb, ccc );				# memcpy関数で第一引数が「aaa.ddd」となっている（他の条件は見ない）
		memcpy( aaa->ddd, bbb, ccc );				# memcpy関数で第一引数が「aaa->ddd」となっている（他の条件は見ない）

　　otherとして抽出されるパターン：
		※基本的にはmemset,memcpy関数はotherに判別されないように上記条件を設定しています。
		　したがってもしotherにmemset,memcpy関数が抽出された場合は正規表現の設定ミスが考えられます。

　　assignとして抽出されるパターン：
		char aaa[10] = {'aaa', 'bbb', 'ccc'};		# char配列型で代入初期化を行っており、NULL(0x00,0,\0,"")を含んでいない

　　assignとして抽出されないパターン：
		char aaa[10] = {'aaa', 'bbb', 'ccc', NULL};	# char配列型で代入初期化を行っているが、NULL(0x00,0,\0,"")を含んでいる
		char aaa[10] = {'aaa', 'bbb', 'ccc', 0x00};	# char配列型で代入初期化を行っているが、NULL(0x00,0,\0,"")を含んでいる
		char aaa[10];								# 宣言のみで代入初期化していないものは抽出しない
		int aaa[10] = {0,1,2,3,4,5,6,7,8,9};		# char配列型以外のもの
		char aaa[] = {'aaa', 'bbb', 'ccc'};			# 配列サイズを明示していないものは抽出しない
		# $Header: /data/cvsrepo/assess-tools/bin/8001_char-memcheck.README,v 1.1 2014/02/24 07:52:34 sodo Exp $								# $Headerを含む行は除外（理由・経緯は不明）
		# sqlstm.									# sqlstm.を含む行は除外（理由・経緯は不明）


