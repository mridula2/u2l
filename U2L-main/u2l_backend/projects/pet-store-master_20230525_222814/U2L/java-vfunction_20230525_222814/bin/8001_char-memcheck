#!/usr/bin/perl
#
# $Header: /data/cvsrepo/assess-tools/bin/8001_char-memcheck,v 1.11 2014/04/01 02:23:21 morimoto Exp $
# $Name: rev_1_10 $
#
# Tool name : 8001_char-memcheck
# Summary: From the output of cppcheck, STK memset and memcpy extract the parts that need visual inspection
# Execution method : 8001_char-memcheck  directory
# Input     : file_list : Cアセスメント対象のファイルリスト
# Output     : Standard output: Output results in the following format
#            <ファイル名><tab><行番号><tab><内容><tab><cppcheckメッセージ>

$DATE=`date "+%Y-%m%d"`;
chomp($DATE);
# cppcheck
$cppcheck="/usr/local/bin/cppcheck";
# script log directory
$logdir=$ENV{PJHOME} . "/log/" . $ENV{APNAME} . "/charinv/" . $DATE;
# STK log file
$stklogdir=$ENV{PJHOME} . "/log/" . $ENV{APNAME} . "/stk/" . $DATE;
$stklogfile="allfunc_detail.txt";
my $fname1;
$fname1 = $1;

if ( $#ARGV != 0 ) {
	print STDERR "Usage : $0 file_list\n";
	exit 1;
}

if ( ! -r $ARGV[0] ) {
	print STDERR "Not found $ARGV[0]\n";
	exit 1;
}

if ( ! -d $logdir ) {
	mkdir $logdir;
}

if ( -f "$logdir/cppcheck.out" ) {
	print STDERR "Using $logdir/cppcheck.out\n";
}
else {
	print STDERR "Executing cppcheck ...\n";
	system("cat $ARGV[0] | xargs $cppcheck --enable=all > $logdir/cppcheck.log 2> $logdir/cppcheck.out");
	print STDERR "Using $logdir/cppcheck.out\n";
}

if ( -f "$stklogdir/$stklogfile" ) {
	print STDERR "Using $stklogdir/$stklogfile\n";
}
else {
	print STDERR "Not found $stklogdir/$stklogfile\n";
	exit 1;
}

#chdir $ARGV[0];

open(my $fh, "cat $logdir/cppcheck.out $stklogdir/$stklogfile | ") || die "Can't open $stklogdir/$stklogfile";

open(my $fhext, "> $logdir/char_memcheck.out") || die "Can't open $logdir/char_memcheck.out";
my $pre="";
while(<$fh>) {
	my $fname, $num, $func, $cppmsg; 
	# STK のログフォーマットからファイル名、行番号、関数を取り出す
	if ( /(\S+):([0-9]+):  \(F\)(\S+)/ ) {
		$fname = $1;
		#print "\n ### checking file_listin 8001: $fname";
		$num = $2;
		$func = $3;
	}
	# cppcheck 出力結果からファイル名、行番号、メッセージを取り出す
	elsif ( /\[([^:]+):([0-9]+)\]:(.*)/ ) {
		$fname = $1;
		#print "\n ### checking file_listin 8001: $fname \n";
		$num = $2;
		$cppmsg = $3;
		if ( $cppmsg =~ /The code contains characters that are unhandled/ ) {
			$func = ""; # Tempory set
		}
		else {
			$func = "cppcheck"; # Tempory set
		}
	}
	# STK で memset, memcpy に関するもの cppcheck の結果であれば以下を処理
	if ( ( $func eq "memset" || $func eq "memcpy" || $func eq "cppcheck" ) && $fname ne "" ) {
			my %vars;
			my %dvars;
			my $bu = 0;
			# cppcheck は.cファイルを対象としているため、
			# ProC(.pc)ファイルがあれば、ファイル名を変更
			#if ( $func eq "cppcheck" ) {
			#	my $pcfile = $fname;
			#	$pcfile =~ s/\.c/\.pc/;
			#	if ( -f "$ENV{PWD}/$pcfile" ) {
			#		$fname = $pcfile;
			#	}
			#}
			open(my $fh2, "$ENV{PWD}/$fname1") || die "Can't open $ENV{PWD}/$fname1";
			#open(my $fh2, "$1") || die "Can't open $1 ";
### sodo debug 2013/08/15: D02
### print $fhext "===== $ENV{PWD}/$fname \n";
			while(<$fh2>) {
				chomp;
				s/	/ /g;
				my $str = $_;
				$str =~ s/"[^"]+"//g;
				$bu+= (() = $str =~ /{/g);
				my $count;
				$count = (() = $str =~ /}/g);
				if ( $count > 0 ) {
					$bu -= $count;
					%dvars = {};
				}
				print STDERR "ERROR $fname $.\n" if ( $bu < 0 );
				if ( /struct\s+(.*)\s+(.*);/ ) {
					$dvars{$2} = $1;
				}
				if ( $. == $num ) {
					if ( $func eq "cppcheck" ) {	
						print $fhext "$fname\t$num\t$_\t$cppmsg\n";
					}
### sodo modify 2013/08/15: M01
### regexp fix for "memset(..." -> OK, "memset (..." -> NG(other)
					#elsif ( /memset\(\s*([^,]+)\s*,\s*.*\s*,\s*sizeof\(\s*(\S+)\s*\)\s*\)/ ) {
### sodo modify 2013/08/15: M04
### regexp fix for "memset(str," -> OK, "memset (str ," -> NG(other)
					#elsif ( /memset\s*\(\s*([^,]+)\s*,\s*.*\s*,\s*sizeof\(\s*(\S+)\s*\)\s*\)/ ) {
					elsif ( $func eq "memset" && /memset\s*\(\s*([^,]+?)\s*,\s*.*\s*,\s*sizeof\(\s*(\S+)\s*\)\s*\)/ ) {
						my $vv = $1;
						my $arg = $2;
						$vv =~ s/^\&//;
### kitayama modify 2013/08/19: M05
### pattern add for "memset((char *)&str," and "memset((char *)str,"
						$vv =~ s/^\(char \*\)\&*//;
						if ( $vv ne $arg ) {
							if ( $dvars{$vv} eq "" ) {
								my $st = "memset-sizeof";
								$st = "memset-struct" if ( $vv =~ /\./ );
								$st = "memset-struct" if ( $vv =~ /->/ );
								print $fhext "$fname\t$num\t$_\t$st\n";
							}
						}
						else {
							print $fhext "$fname\t$num\t$_\tmemset-OK\n";
							$vars{$vv} = $bu;
### sodo debug 2013/08/15: D01
### print $fhext "\$vars\{$vv\} = $bu;\n";
						}
					}
### sodo modify 2013/08/15: M02
### regexp fix for "memset(..." -> OK, "memset (..." -> NG(other)
					#elsif ( /memset\(\s*([^,.]+)\s*,/ ) {
### kitayama modify 2013/08/19: M02
### regexp fix for "struct from other to struct in memset-other"
					#elsif ( /memset\s*\(\s*([^,.]+)\s*,/ ) {
					elsif ( $func eq "memset" && /memset\s*\(\s*([^,]+)\s*,/ ) {
						my $vv = $1;
						my $st = "";
						$vv =~ s/^\&//;
						$vv =~ s/\[[0-9]+\]//;
						$st = "memset-struct" if ( $vv =~ /\./ );
						$st = "memset-struct" if ( $vv =~ /->/ );
						if ($st eq "memset-struct") {
							print $fhext "$fname\t$.\t$_\t$st\n";
						}
						else {
							print $fhext "$fname\t$.\t$_\tmemset-other\n";
						}
					}
### kitayama add 2013/08/19
					elsif ( $func eq "memcpy" && /memcpy\s*\(\s*([^,]+?)\s*,\s*([^,]+)\s*,\s*sizeof\(\s*(\S+)\s*\)\s*\)/ ) {
						my $vv = $1;
						my $ww = $2;
						my $arg = $3;
						$ww =~ s/^\&//;
						$ww =~ s/^\(char \*\)\&*//;
						if ( $ww ne $arg ) {
							my $st = "memcpy-sizeofNE";
							$st = "memcpy-struct" if ( $vv =~ /\./ );
							$st = "memcpy-struct" if ( $vv =~ /->/ );
							print $fhext "$fname\t$num\t$_\t$st\n";
						}
						else {
							print $fhext "$fname\t$num\t$_\tmemcpy-sizeofEQ\n";
						}

					}
### sodo modify 2013/08/15: M03
### regexp fix for "memcpy(..." -> OK, "memcpy (..." -> NG(other)
					#elsif ( /memcpy\(\s*([^,]+)\s*,/ ) {
					elsif ( $func eq "memcpy" && /memcpy\s*\(\s*([^,]+)\s*,/ ) {
						my $vv = $1;
						my $st = "";
						$vv =~ s/^\&//;
						$vv =~ s/\[[0-9]+\]//;
						$st = "memcpy-struct" if ( $vv =~ /\./ );
						$st = "memcpy-struct" if ( $vv =~ /->/ );
						$vv =~ s/\..*//;
						if ( $vars{$vv} eq "" ) {
							print $fhext "$fname\t$.\t$_\t$st\n";
						}
						else {
							print $fhext "$fname\t$num\t$_\tmemcpy\n";
						}
					}
					elsif ( /(.*)\[.*\]\s*=\s*/ ) {
						my $vv = $1;
						my $st = "";
						$vv =~ s/^\&//;
						$vv =~ s/\[[0-9]+\]//;
						$st = "memcpy-struct" if ( $vv =~ /\./ );
						$st = "memcpy-struct" if ( $vv =~ /->/ );
						$vv =~ s/\..*//;
						if ( $vars{$vv} eq "" ) {
							print $fhext "$fname\t$.\t$_\t$st\n";
						}
						else {
							print $fhext "$fname\t$num\t$_\tassign\n";
						}
					}
					else {
						print $fhext "$fname\t$num\t$_\tother\n";
					}
				}
				#print "LINE $.\n";
				#foreach my $key ( keys( %vars ) ) {
				#    print "キー値 : $key\n";
				#    print "値 : $vars{$key} \n "
				#} 
			}
			close($fh2);
			$pre = $fname;
	}
}

close($fh);

#  char 配列要素初期化箇所の抽出
open my $findfh, "find -L . -name \*.c -o -name \*.pc -print -follow | " || die "Can't execute.";

while (<$findfh>) {
	my $filename=$_;
	chomp($filename);
	open(my $fh3, "$filename") || die "Can't open $filename";
	#print "FILENAME : $filename\n";
	my %varnames;
	while(<$fh3>) {
		chomp;
		s/	/ /g;
		if ( /^\s*([^,=\(\s]+)\s+([^\[\s=\(]+)\[[^\]]+\]/ ) {
			my $type=$1;
			my $valname=$2;
			#print "$filename\t$.\t$_";
			#print "\tType : $type   VAL : $valname\n";
			$varnames{$valname} = $type;
		}
		if ( /^\s*([^>]+)\[..*\]\s*=\s*([^=].*)/ ) {
			my $vname = $1;
			next if ( /sqlstm\./ );
			next if ( /\$Header:/ );
			next if ( /\\0/ );
			next if ( /0x00;/ );
			next if ( /0;/ );
			next if ( /NULL;/ );
			next if ( /"";/ );
			if ( $varnames{$vname} eq "" || 
				$varnames{$vname} =~ /char/ ) {
				print $fhext "$filename\t$.\t$_\tassign\n";
				#print "A $filename\t$.\t$_";
				#print "\tVAR \"$vname\" : $varnames{$vname}\n";
			}
		}
	}
	close($fh3);
}
close($findfh);
close($fhext);
