#!/usr/bin/perl
#
# $Header: /data/cvsrepo/assess-tools/bin/0000_classify_files,v 1.6 2016/01/29 02:23:44 kozeni Exp $
# $Name: rev_1_10 $
#
# ツール名 : 0000_classify_file
# 概要     : 指定されたディレクトリにあるファイルをC,sh等の種別ごとのファイルリストを作成する
# 実行方法 : 0000_classify_file dirname
# 入力	   : dirname    : アセスメント対象ディレクトリ
# 出力     : $PJHOME/log/$APNAME/srccheck/YYYY-MMDD 上に以下のファイルを作成する
#	c_files.out	: Cソースファイルリスト
#	make_files.out	: Makefileリスト
#	build_files.out : ビルド用スクリプトリスト
#	exclude_files.out : アセスメント対象外のファイルリスト
#	java_files.out	: Java ファイルリスト
#	check_files.out : スクリプトでは識別できないファイルリスト
#	ksh_list.out	: ksh/bash スクリプトリスト
#	csh_list.out	: csh スクリプトリスト
#	awk_list.out	: awk スクリプトリスト
#	ot*_list.out	: スクリプトでは識別できないファイルリスト
#

use strict;
use warnings;

# 生成したファイルを保存するディレクトリ
my $logdir=$ENV{PJHOME} . "/log/" . $ENV{APNAME} . "/srccheck";
my $logdate;

my $STK_CONFIG="/etc/opt/STK/config/client";
my $STKSL_CONFIG="/etc/opt/STKSL/config/client";
my $listshellcmd="/usr/local/hpscan/shanalyze/listshells.sh";
my $filecmd="/usr/bin/file";
my @c_ext;
my @cpp_ext;
my @script_ext;
my @java_ext = qw(java jsp);
my @php_ext = qw(php phar);
my @makefile_ext;
my @makefile_first;
my @exclude_ext;
my $exclude_str = "lis out i sql pck info new inf SQL";
my @exclude_first;
my @exclude_dir = qw( CADVISE_IELFS.coll CADVISE_LOGS.coll CADVISE_TEXT.coll );

# 結果を保存する配列
my @c_files;
my @cpp_files;
my @script_files;
my @build_script_files;
my @makefiles;
my @exclude_files;
my @chk_files;
my @java_files;
my @php_files;
my %script_list = (
	bsh => "ksh_list.out",
	ksh => "ksh_list.out",
	csh => "csh_list.out",
	awk => "awk_list.out",
	ot1 => "ot1_list.out",
	ot2 => "ot2_list.out"
);

# ファイルにリスト結果を出力
sub print_files
{
	my ($outname, @a) = @_;

	if ( $#a < 0 ) {
		return; 
	}
	print "Creating $outname ...in $logdir/$logdate\n";
	open(my $fh, "> $logdir/$logdate/$outname") || die("ERROR: Can't open $logdir/$logdate/$outname");

	foreach(@a) {
		print $fh "$_\n";
	}

	close($fh);
}
1;

# sh/csh 等シェルごとにファイルに出力
sub print_script_files
{
	my (@a) = @_;

	if ( $#a < 0 ) {
		return; 
	}
        system ("rm -rf  $logdir/$logdate/*" );
	foreach my $fname (@a) {
		my $sname;
		open(my $fh, "$listshellcmd $fname | ") 
				  or die("ERROR: Can't execute listshells.sh $fname");
        while(<$fh>) {
			$sname = $1 if ( /^(\S+) / );
		}
		close($fh);
                if ( $sname ne "ksh" && $sname ne "csh" && $sname ne "sh" && $sname ne "bsh" && $sname ne "awk" )
		{
                my $shell_ext;
                $shell_ext=substr($fname, rindex($fname, '.') + 1);
                if ( $shell_ext eq "sh" || $shell_ext eq "bsh" || $shell_ext eq "ksh" )
                {
                  $sname="ksh";
                }
                if ( $shell_ext eq "csh" )
                {
                 $sname="csh";
                }
                }
		print "listshells result -> $sname\n";
        open(my $fh2, ">> $logdir/$logdate/$script_list{$sname}") || die("ERROR: Can't open $logdir/$logdate/$script_list{$sname}");
		print $fh2 "$fname\n";
		close($fh2);
	}
}

# cc, make を実行していればビルドスクリプトとみなす
sub check_build_script
{
	my $file = $_[0];
	my $ret = 0;

	open(my $fhs, "$file") || die("ERROR: Can't open $file");

	while(<$fhs>) {
		if ( /^\s*cc / || /^\s*make / ) {
			$ret = 1;
			last;
		}
	}

	close($fhs);
	return $ret;
}

#
# Main
#

# 保存ディレクトリ名の作成( YYYY-MMDD )
my @today=localtime(time);
$logdate= sprintf "%d-%02d%02d", $today[5]+1900, $today[4]+1, $today[3];

# ディレクトリが存在したらエラーにしていたが、存在しなければ作成するように修正
#if ( -d "$logdir/$logdate" ) {
#	die "ERROR: Already exists directory : $logdir/$logdate";
#}
#else {
#	my $ret = system( "mkdir -p $logdir/$logdate" );
#	if ( $ret != 0 ) {
#		die( "ERROR: Can't mkdir -p $logdir/$logdate" );
#	}
#}
if (! -d "$logdir/$logdate" ) {
	my $ret = system( "mkdir -p $logdir/$logdate" );
	if ( $ret != 0 ) {
		die( "ERROR: Can't mkdir -p $logdir/$logdate" );
	}
}

my $fhstk;
open($fhstk, "$STK_CONFIG") || open($fhstk, "$STKSL_CONFIG") || die("ERROR: Can't open $STK_CONFIG, $STKSL_CONFIG");

while(<$fhstk>) {
	if ( /^C_EXTENSIONS\s+= (.*)/ ) {
		@c_ext = split(/\s+/, $1);
		#@cpp_ext = split(/\s+/, $1);
	}
        if ( /^CXX_EXTENSIONS\s+= (.*)/ ) {
                @cpp_ext = split(/\s+/, $1);
        }

	if ( /^SCRIPT_EXTENSIONS\s+= (.*)/ ) {
		@script_ext = split(/\s+/, $1);
	}
	if ( /^MAKE_EXTENSIONS\s+= (.*)/ ) {
		@makefile_ext = split(/\s+/, $1);
	}
	if ( /^MAKE_FIRSTNAMES\s+= (.*)/ ) {
		@makefile_first = split(/\s+/, $1);
	}
	if ( /^EXCLUDE_EXTENSIONS\s+= (.*)/ ) {
		$exclude_str .= " $1";
	}
	if ( /^EXCLUDE_FIRSTNAMES\s+= (.*)/ ) {
		@exclude_first = split(/\s+/, $1);
	}
}

@exclude_ext = split(/\s+/, $exclude_str);

close($fhstk);

if ( ! defined($ARGV[0]) ) {
	print STDERR "Usage: $0 dir_name\n";
	exit 1;
}
#open(my $fh, "ls -Rb $ARGV[0] |") || die("Can't open");
open(my $fh1, "find $ARGV[0] -type f |") || die("ERROR: Can't open");

my $cdir;
my $wout=0;
while(<$fh1>) {
	chomp;
	$wout = 0;
	my $fname = $_;
	s/.*\///;
	my @a=split(/\./, $_);
        # ファイル名、拡張子にもとづき分類
	foreach(@makefile_first) {
		if ( $_ eq $a[0]  ) {
			print "$_ : $fname\t";
			push(@makefiles, $fname);
			$wout = 1;
			last;
		}
	}
	foreach(@exclude_first) {
		if ( $_ eq $a[0]  ) {
			$wout = 1;
			push(@exclude_files, $fname);
			last;
		}
	}
	if ( $#a > 0 ) {
	        # C 
		foreach(@c_ext) {
			if ( $_ eq $a[$#a]  ) {
				print "$_ : $fname\n";
				push(@c_files, $fname);
				$wout = 1;
				last;
			}
		}

		# script
		foreach my $ext (@script_ext) {
			if ( $ext eq $a[$#a] ) {
				print "$_ : $fname\n";	
				if ( &check_build_script($fname) ) {
					push(@build_script_files, $fname);
				}		
				else {
					push(@script_files, $fname);
				}
				$wout = 1;
				last;
			}
		}
		# Java
		foreach(@java_ext) {
			if ( $_ eq $a[$#a]  ) {
				print "$_ : $fname\n";	
				push(@java_files, $fname);
				$wout = 1;
				last;
			}
		}
		# php
                foreach(@php_ext) {
                        if ( $_ eq $a[$#a]  ) {
                                print "$_ : $fname\n";
                                push(@php_files, $fname);
                                $wout = 1;
                                last;
                        }
                }

		 #Cpp
                foreach(@cpp_ext) {
                       if ( $_ eq $a[$#a]  ) {
                                print "$_ : $fname\n";
                                push(@cpp_files, $fname);
                                $wout = 1;
                               last;
                        }
                }

		# Makefile
		foreach(@makefile_ext) {
			if ( $_ eq $a[$#a]  ) {
				print "$_ : $fname\n";	
				#print "line number 456 make  \n";
				push(@makefiles, $fname);
				$wout = 1;
				last;
			}
		}
		foreach my $ext (@exclude_ext) {
			next if ( ! defined($ext) );
			if ( $ext eq $a[$#a]  ) {
				$wout = 1;
				if ( &check_build_script($fname) ) {
					push(@build_script_files, $fname);
				}		
				else {
					push(@exclude_files, $fname);
				}
				last;
			}
		}
	}
	# ファイル名、拡張子から判断できない場合は、
	# file コマンド出力結果より分類
	if ( $wout == 0 ) {
		open(my $fefh, "$filecmd $fname | ") || die("ERROR: Can't execute $filecmd.");
		while(<$fefh>) {
		   if ( /Berkeley DB/ ) {
			  last;
		   }	 
		   elsif ( /make commands/ || /makefile script/ ) {
				print "make : $fname \n";
				#print "line number 1000 \n";	
				push(@makefiles, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /shell script/ ) {
				print "shell : $fname \n";	
				push(@script_files, $fname);
				$wout = 1;
				last;
		   }
		   # 
		   elsif ( /C program/ || /ASCII text/ || /ISO-8859 text/ || /C\+\+ program/ || /ASCII English text/ || /Pascal program/ || /: UTF-8 Unicode text/) {
				print "chk : $fname \n";	
				push(@chk_files, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /relocatable object/ || /ar archive/ || /executable/ || /shared object/ || /archive file/ || /shared library/ ) {
				print "ext : $fname \n";	
				push(@exclude_files, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /empty/ ) {
				print "empty : $fname \n";	
				push(@exclude_files, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /data/ ) {
				print "empty : $fname \n";	
				push(@exclude_files, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /XML/ || /HTML/ ) {
				print "empty : $fname \n";	
				push(@exclude_files, $fname);
				$wout = 1;
				last;
		   }
		   elsif ( /Java/ ) {
				print "java : $fname \n";
			#	print "line number 334 java`";
				push(@java_files, $fname);
				$wout = 1;
				last;
		   }
		elsif ( /C/ ) {
                                print "c : $fname \n";
                                push(@c_files, $fname);
                                $wout = 1;
                                last;
                   }
		elsif ( /Cpp/ ) {
                                print "cpp : $fname \n";
                                push(@c_files, $fname);
                                $wout = 1;
                                last;
                   }

		   else {
			  print STDERR "ERROR: Can't find $_";
		   }
		}
		close($fefh);
		next if ( $wout );
		my $mode = (stat($fname))[2];
	    if ( ! ( $mode & 01111 ) ) {
			$wout = 1;
			push(@exclude_files, $fname);
			next;
		}
		foreach(@exclude_dir) {
			if ( $fname =~ /$_/  ) {
				$wout = 1;
				push(@exclude_files, $fname);
				last;
			}
		}
	}
	# ファイル名、fileコマンドでも判断できない場合 check_files に保存し、
	# 作業者に確認させる
	if ( $wout == 0 ) {
		push(@chk_files, $fname);
#		print "Not entry found \"$fname\" \n";
	}
}

close($fh1);

# 結果をファイルに出力
print_script_files(@script_files);
print_files("c_files.out", @c_files);
print_files("cpp_files.out", @cpp_files);
print_files("make_files.out", @makefiles);
#print_files("script_files.out", @script_files);
#print_script_files(@script_files);
print_files("build_files.out", @build_script_files);
print_files("exclude_files.out", @exclude_files);
print_files("java_files.out", @java_files);
print_files("php_files.out", @php_files);
print_files("check_files.out", @chk_files);
